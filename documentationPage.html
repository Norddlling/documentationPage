<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="keywords" content="JSON, JSON syntax, JavaScript Object Notation"/>
    <meta name="description" content="Technical documentation about JSON data and syntax"/>
    <meta name="author" content="Ihor Poberezhnii"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>The JSON Data Interchange Syntax</title>
    <link rel="stylesheet" href="styles.css"/>
  </head>

  <body>
    <nav id="navbar">
      <header>
        <h1>The JSON Data Interchange Syntax</h1>
      </header>
      <a class="nav-link" href="#introduction">Introduction</a>
      <a class="nav-link" href="#scope">Scope</a>
      <a class="nav-link" href="#conformance">Conformance</a>
      <a class="nav-link" href="#normative_references">Normative References</a>
      <a class="nav-link" href="#json_text">JSON Text</a>
      <a class="nav-link" href="#json_values">JSON Values</a>
      <a class="nav-link" href="#objects">Objects</a>
      <a class="nav-link" href="#arrays">Arrays</a>
      <a class="nav-link" href="#numbers">Numbers</a>
      <a class="nav-link" href="#string">String</a>
      <a class="nav-link" href="#reference">Reference</a>
    </nav>

    <main id="main-doc">
      <section class="main-section" id="introduction">
        <header>
          <h1>Introduction</h1>
        </header>
        <p><span class="hint" title="Pronounced /ˈdʒeɪ·sən/, as in “Jason and The Argonauts”">JSON</span> is a text syntax that facilitates structured data interchange between all programming languages. JSON is a syntax of braces, brackets, colons, and commas that is useful in many contexts, profiles, and applications. JSON stands for JavaScript Object Notation and was inspired by the object literals of JavaScript aka ECMAScript as defined in the ECMAScript Language Specification, <span class="hint" title="ECMA-262, ECMAScript® Language Specification">Third Edition.</span> However, it does not attempt to impose ECMAScript’s internal data representations on other programming languages. Instead, it shares a small subset of ECMAScript’s syntax with all other programming languages. The JSON syntax is not a specification of a complete data interchange. Meaningful data interchange requires agreement between a
producer and consumer on the semantics attached to a particular use of the JSON syntax. What JSON does provide is the syntactic framework to which such semantics can be attached </p>
        <p>JSON syntax describes a sequence of Unicode code points. JSON also depends on Unicode in the hex numbers used in the <code>\u</code> escapement notation.</p>
        <p>JSON is agnostic about the semantics of numbers. In any programming language, there can be a variety of number types of various capacities and complements, fixed or floating, binary or decimal. That can make interchange between different programming languages difficult. JSON instead offers only the representation of numbers that humans use: a sequence of digits. All programming languages know how to make sense of digit sequences even if they disagree on internal representations. That is enough to allow interchange.</p>
        <p>Programming languages vary widely on whether they support objects, and if so, what characteristics and constraints the objects offer. The models of object systems can be wildly divergent and are continuing to evolve. JSON instead provides a simple notation for expressing collections of name/value pairs. Most programming languages will have some feature for representing such collections, which can go by names like <code>record</code>, <code>struct</code>, <code>dict</code>, <code>map</code>, <code>hash</code>, or <code>object</code>.</p>
        <p>JSON also provides support for ordered lists of values. All programming languages will have some feature for representing such lists, which can go by names like <code>array</code>, <code>vector</code>, or <code>list</code>. Because objects and arrays
can nest, trees and other complex data structures can be represented. By accepting JSON’s simple convention, complex data structures can be easily interchanged between incompatible programming languages.</p>
        <p>JSON does not support cyclic graphs, at least not directly. JSON is not indicated for applications requiring binary data.</p>
        <p>It is expected that other standards will refer to this one, strictly adhering to the JSON syntax, while imposing semantics interpretation and restrictions on various encoding details. Such standards may require specific behaviours. JSON itself specifies no behaviour.</p>
        <p>Because it is so simple, it is not expected that the JSON grammar will ever change. This gives JSON, as a foundational notation, tremendous stability.</p>
       <p>JSON was first presented to the world at the <a href="https://www.json.org/">JSON.org</a> website in 2001. A definition of the JSON syntax was subsequently published as IETF RFC 4627 in July 2006. ECMA-262, Fifth Edition (2009) included a normative specification of the JSON grammar. This specification, ECMA-404, replaces those earlier definitions of the JSON syntax. Concurrently, the IETF published RFC 7158/7159 and in 2017 RFC 8259 as updates to RFC 4627. The JSON syntax specified by this specification and by RFC 8259 are intended to be identical.</p>
      </section>
      
      <section class="main-section" id="scope">
        <header>
          <h1>Scope</h1>
        </header>
        <p>JSON is a lightweight, text-based, language-independent syntax for defining data interchange formats. It was derived from the ECMAScript programming language, but is programming language independent. JSON defines a small set of structuring rules for the portable representation of structured data.</p>
        <p>The goal of this specification is only to define the syntax of valid JSON texts. Its intent is not to provide any semantics or interpretation of text conforming to that syntax. It also intentionally does not define how a valid JSON text might be internalized into the data structures of a programming language. There are many possible semantics that could be applied to the JSON syntax and many ways that a JSON text can be processed or mapped by a programming language. Meaningful interchange of information using JSON requires agreement among the involved parties on the specific semantics to be applied. Defining specific semantic interpretations of JSON is potentially a topic for other specifications. Similarly, language mappings of JSON can also be
independently specified. For example, ECMA-262 defines mappings between valid JSON texts and ECMAScript’s runtime data structures.</p>
      </section>
      <section class="main-section" id="conformance">
        <header>
          <h1>Conformance</h1>
        </header>
        <p>A conforming JSON text is a sequence of Unicode code points that strictly conforms to the JSON grammar defined by this specification.</p>
        <p>A conforming processor of JSON texts should not accept any inputs that are not conforming JSON texts. A conforming processor may impose semantic restrictions that limit the set of conforming JSON texts that it will process.</p>
      </section>
      <section class="main-section" id="normative_references">
        <header >
          <h1>Normative References</h1>
        </header>
        <p>The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
        <p>ISO/IEC 10646, Information Technology – Universal Coded Character Set (UCS)</p>
        <p>The Unicode Consortium. The Unicode Standard <a href="http://www.unicode.org/versions/latest">http://www.unicode.org/versions/latest</a>.</p>
        <p>Bray, T., Ed. "The JavaScript Object Notation (JSON) Data Interchange Format", RFC 8259.</p>
        <p>This specification and [RFC 8259] both provide specifications of the JSON grammar but do so using different
formalisms. The intent is that both specifications define the same syntactic language. If a difference is found between them, Ecma International and the IETF will work together to update both documents. If an error is found with either document, the other should be examined to see if it has a similar error, and fixed if possible. If either document is changed in the future, Ecma International and the IETF will work together to ensure that
the two documents stay aligned through the change. RFC 8259, also defines various semantic restrictions on the use of the JSON syntax. Those restrictions are not normative for this specification.</p>
      </section>
      <section class="main-section" id="json_text">
        <header>
          <h1>JSON Text</h1>
        </header>
        <p>A JSON text is a sequence of tokens formed from Unicode code points that conforms to the JSON value grammar. The set of tokens includes six structural tokens, strings, numbers, and three literal name tokens.</p>
        <p>The six structural tokens:</p>
        <ul>
          <li>[ - U+005B - left square bracket</li>
          <li>{ - U+007B - left curly bracket</li>
          <li>] - U+005D - right square bracket</li>
          <li>} - U+007D - right curly bracket</li>
          <li>: - U+003A - colon</li>
          <li>, - U+002C - comma </li>
        </ul>
          <p>These are the three literal name tokens:</p>
        <ul>
          <li><code>true</code> - U+0074 U+0072 U+0075 U+0065</li>
          <li><code>false</code> - U+0066 U+0061 U+006C U+0073 U+0065</li>
          <li><code>null</code> - U+006E U+0075 U+006C U+006C</li>
        </ul>
        <p>Insignificant whitespace is allowed before or after any token. Whitespace is any sequence of one or more of the following code points: character tabulation (U+0009), line feed (U+000A), carriage return (U+000D), and space (U+0020). Whitespace is not allowed within any token, except that space is allowed in strings.</p>
      </section>
      <section class="main-section" id="json_values">
        <header>
          <h1>JSON Values</h1>
        </header>
        <p>A JSON value can be an object, array, number, string, <code>true</code>, <code>false</code>, or <code>null</code>.</p>
      </section>
      <section class="main-section"  id="objects">
        <header>
          <h1>Objects</h1>
        </header>
        <p>An object structure is represented as a pair of curly bracket tokens surrounding zero or more name/value pairs. A name is a <em>string</em>. A single colon token follows each name, separating the name from the <em>value</em>. A single comma token separates a <em>value</em> from a following name. The JSON syntax does not impose any restrictions on the <em>strings</em> used as names, does not require that name <em>strings</em> be unique, and does not assign any significance to the ordering of name/value pairs. These are all semantic considerations that may be defined by JSON processors or in specifications defining specific uses of JSON for data interchange</p>
      </section>
      <section class="main-section" id="arrays">
        <header>
          <h1>Arrays</h1>
        </header>
        <p>An array structure is a pair of square bracket tokens surrounding zero or more <em>values</em>. The <em>values</em> are separated by commas. The JSON syntax does not define any specific meaning to the ordering of the <em>values</em>. However, the JSON array structure is often used in situations where there is some semantics to the ordering. </p>
      </section>
      <section class="main-section"  id="numbers">
        <header>
          <h1>Numbers</h1>
        </header>
        <p>A number is a sequence of decimal digits with no superfluous leading zero. It may have a preceding minus sign (U+002D). It may have a fractional part prefixed by a decimal point (U+002E). It may have an exponent, prefixed by <code>e</code> (U+0065) or <code>E</code> (U+0045) and optionally <code>+</code> (U+002B) or <code>–</code> (U+002D). The digits are the code points U+0030 through U+0039.</p>
        <p>Numeric values that cannot be represented as sequences of digits (such as <code>Infinity</code> and <code>NaN</code>) are not permitted.</p>
      </section>
      <section class="main-section"  id="string">
        <header>
          <h1>String</h1>
        </header>
        <p>A string is a sequence of Unicode code points wrapped with quotation marks (U+0022). All code points may be placed within the quotation marks except for the code points that must be escaped: quotation mark (U+0022), reverse solidus (U+005C), and the control characters U+0000 to U+001F. There are two-character escape sequence representations of some characters.</p>
        <ul>
          <li><code>\"</code> - represents the quotation mark character (U+0022).</li>
          <li><code>\\</code> - represents the reverse solidus character (U+005C).</li>
          <li><code>\/</code> - represents the solidus character (U+002F). </li>
          <li><code>\b</code> - represents the backspace character (U+0008).</li>
          <li><code>\f</code> - represents the form feed character (U+000C).</li>
          <li><code>\n</code> - represents the line feed character (U+000A).</li>
          <li><code>\r</code> - represents the carriage return character (U+000D).</li>
          <li><code>\t</code> - represents the character tabulation character (U+0009).</li>
        </ul>
        <p>So, for example, a string containing only a single reverse solidus character may be represented as <code>"\\"</code>.</p>
        <p>Any code point may be represented as a hexadecimal escape sequence. The meaning of such a hexadecimal number is determined by ISO/IEC 10646. If the code point is in the Basic Multilingual Plane (U+0000 through U+FFFF), then it may be represented as a six-character sequence: a reverse solidus, followed by the lowercase letter u, followed by four hexadecimal digits that encode the code point. Hexadecimal digits can be
© Ecma International 2017 5 digits (U+0030 through U+0039) or the hexadecimal letters <code>A</code> through <code>F</code> in uppercase (U+0041 through U+0046) or lowercase (U+0061 through U+0066). So, for example, a string containing only a single reverse solidus character may be represented as <code>"\u005C"</code>.</p>
        <p>The following four cases all produce the same result:</p>
        <ul>
          <li><code>"\u002F"</code></li>
          <li><code>"\u002f"</code></li>
          <li><code>"\/"</code></li>
          <li><code>"/"</code></li>
        </ul>
        <p>To escape a code point that is not in the Basic Multilingual Plane, the character may be represented as a
twelve-character sequence, encoding the UTF-16 surrogate pair corresponding to the code point. So for example, a string containing only the G clef character (U+1D11E) may be represented as <code>"\uD834\uDD1E"</code>. However, whether a processor of JSON texts interprets such a surrogate pair as a single code point or as an explicit surrogate pair is a semantic decision that is determined by the specific processor.</p>
        <p>Note that the JSON grammar permits code points for which Unicode does not currently provide character assignments.</p>
      </section>
      <section class="main-section"  id="reference">
        <header>
          <h1>Reference</h1>
        </header>
        <p>All the documentation in this page is taken from <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf">ecma-international</a>.</p>
      </section>
    </main>
  </body>
</html>
